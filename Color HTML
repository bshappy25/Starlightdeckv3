<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Sandbox A â€” Paint With Light</title>

  <!-- ðŸŸ¢ STYLE ZONE -->
  <style>
    :root{
      --ink1:#050714;
      --ink2:#0a1030;
      --panel: rgba(255,255,255,0.06);
      --panel-border: rgba(255,255,255,0.12);
      --text: rgba(255,255,255,0.92);
      --muted: rgba(255,255,255,0.70);

      /* Ethereal palette (swatches use these) */
      --ether-ink: #0f1224;
      --ether-starlight: #f5f7ff;
      --ether-lavender: #c9c2ff;
      --ether-cyan: #8fe3ff;
      --ether-rose: #f2a6c9;
      --ether-gold: #ffd89e;

      /* Black (shape mode) */
      --ether-black: #111111;
    }

    /* Save Light button */
    .save-light{
      position: relative;
      background: rgba(210, 230, 255, 0.10);
      border: 1px solid rgba(255,255,255,0.18);
      box-shadow:
        0 0 10px rgba(180,220,255,0.18),
        0 0 22px rgba(180,220,255,0.10);
      animation: savePulse 2.2s ease-in-out infinite;
    }

    @keyframes savePulse{
      0%, 100%{
        box-shadow:
          0 0 10px rgba(180,220,255,0.16),
          0 0 22px rgba(180,220,255,0.08);
      }
      50%{
        box-shadow:
          0 0 14px rgba(200,240,255,0.28),
          0 0 34px rgba(200,240,255,0.16);
      }
    }

    .clear-x{
      margin-left:auto;
      width:36px;
      height:36px;
      border-radius:50%;
      display:flex;
      align-items:center;
      justify-content:center;
      font-size:1.2rem;
      font-weight:700;
      line-height:1;
      background: rgba(255,255,255,0.06);
      border:1px solid rgba(255,255,255,0.18);
      color: rgba(255,255,255,0.8);
    }

    .clear-x:hover{
      background: rgba(255,255,255,0.12);
    }

    .clear-x:active{
      transform: scale(0.96);
    }

    .color-swatch{
      width:28px;
      height:28px;
      border-radius:50%;
      border:1px solid rgba(255,255,255,0.35);
      cursor:pointer;
      box-shadow: 0 0 6px rgba(255,255,255,0.25);
      transition: transform 120ms ease, box-shadow 120ms ease, border-color 120ms ease;
    }

    .color-swatch:hover{
      transform: scale(1.05);
    }

    /* Active ring */
    .color-swatch.active{
      border-color: rgba(255,255,255,0.85);
      box-shadow:
        0 0 8px rgba(255,255,255,0.28),
        0 0 18px rgba(190,220,255,0.18);
    }

    body{
      margin:0;
      min-height:100vh;
      display:flex;
      flex-direction:column;
      align-items:center;
      justify-content:flex-start;
      background:
        radial-gradient(1200px 700px at 20% 10%, rgba(120,180,255,0.12), transparent 60%),
        radial-gradient(900px 600px at 80% 0%, rgba(180,120,255,0.10), transparent 55%),
        linear-gradient(180deg, var(--ink1), var(--ink2));
      color:var(--text);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
    }

    .wrap{
      width:min(980px, 96vw);
      margin:18px auto 28px;
      display:flex;
      flex-direction:column;
      gap:12px;
    }

    .title{
      letter-spacing:0.08em;
      font-weight:800;
      font-size:0.95rem;
      opacity:0.95;
    }

    .subtitle{
      margin-top:4px;
      color:var(--muted);
      font-size:0.9rem;
    }

    /* ðŸŸ¢ UI PANEL */
    .panel{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      align-items:center;
      padding:12px 12px;
      border-radius:16px;
      background: var(--panel);
      border: 1px solid var(--panel-border);
      backdrop-filter: blur(8px);
    }

    .pill{
      display:flex;
      align-items:center;
      gap:8px;
      padding:8px 10px;
      border-radius:14px;
      border: 1px solid rgba(255,255,255,0.10);
      background: rgba(0,0,0,0.18);
      color: var(--muted);
      font-size:0.88rem;
    }

    .pill input[type="range"]{
      width:120px;
    }

    button{
      appearance:none;
      border:none;
      cursor:pointer;
      padding:10px 12px;
      border-radius:14px;
      background: rgba(255,255,255,0.10);
      color: var(--text);
      border:1px solid rgba(255,255,255,0.14);
      font-weight:650;
      letter-spacing:0.02em;
    }

    button:active{
      transform: translateY(1px);
    }

    /* Shape buttons */
    .shape-btn{
      padding:8px 10px;
      border-radius:12px;
      font-weight:700;
      background: rgba(255,255,255,0.06);
      border:1px solid rgba(255,255,255,0.14);
      color: rgba(255,255,255,0.85);
    }

    .shape-btn.active{
      background: rgba(255,255,255,0.14);
      border-color: rgba(255,255,255,0.28);
      color: rgba(255,255,255,0.95);
    }

    /* CANVAS STAGE */
    .stage{
      position: relative;
      border-radius:18px;
      border: 1px solid rgba(255,255,255,0.14);
      background: rgba(255,255,255,0.03);
      padding:10px;
      margin: 0 auto;
      overflow: hidden; /* keeps animated bg rounded */
    }

    /* Animated grey/ink gradient behind the canvas (S2A) */
    .stage::before{
      content:"";
      position:absolute;
      inset:10px;
      border-radius:14px;
      background:
        radial-gradient(900px 520px at 20% 20%, rgba(220,230,255,0.10), transparent 60%),
        radial-gradient(700px 420px at 80% 10%, rgba(170,180,210,0.10), transparent 55%),
        linear-gradient(180deg, #070a16, #1b1f2a);
      filter: saturate(0.95) contrast(1.05);
      animation: inkDrift 50s ease-in-out infinite alternate;
      z-index:0;
    }

    @keyframes inkDrift{
      0%{
        transform: translate3d(-1.5%, -1%, 0) scale(1.02);
        opacity: 0.95;
      }
      50%{
        transform: translate3d(1.5%, 0.5%, 0) scale(1.03);
        opacity: 1;
      }
      100%{
        transform: translate3d(0.5%, 1.2%, 0) scale(1.02);
        opacity: 0.92;
      }
    }

    canvas{
      position: relative;
      z-index:1;
      display:block;
      width:100%;
      height: min(70vh, 560px);
      background: transparent; /* live background is the stage gradient */
      border-radius:14px;
      touch-action:none;

      /* Magical wand cursor (canvas only) */
      cursor: url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='32' height='32' viewBox='0 0 32 32'><path d='M6 26 L22 10' stroke='%238fe3ff' stroke-width='3' stroke-linecap='round'/><path d='M20 8 L24 12' stroke='%23ffffff' stroke-width='2' stroke-linecap='round' opacity='0.9'/><circle cx='24' cy='8' r='2' fill='%238fe3ff'/><circle cx='26.5' cy='12' r='1.5' fill='%23ffffff' opacity='0.9'/></svg>") 4 28, auto;
    }

    @media (max-width: 520px){
      canvas{
        height: 62vh;
      }
    }

    .footer{
      color: var(--muted);
      font-size:0.85rem;
      text-align:left;
      padding: 2px 4px;
    }
  </style>
</head>

<body>
  <div class="wrap">
    <div>
      <div class="title">âœ¨ SANDBOX A â€” PAINT WITH LIGHT</div>
      <div class="subtitle">Minimal. Calm. One change at a time.</div>
    </div>

    <div class="panel">
      <div class="pill">
        <span>Light</span>

        <!-- Order: ink, starlight, lavender, cyan, rose, gold -->
        <div class="color-swatch active" data-color="var(--ether-ink)" style="background:var(--ether-ink)"></div>
        <div class="color-swatch" data-color="var(--ether-starlight)" style="background:var(--ether-starlight)"></div>
        <div class="color-swatch" data-color="var(--ether-lavender)" style="background:var(--ether-lavender)"></div>
        <div class="color-swatch" data-color="var(--ether-cyan)" style="background:var(--ether-cyan)"></div>
        <div class="color-swatch" data-color="var(--ether-rose)" style="background:var(--ether-rose)"></div>
        <div class="color-swatch" data-color="var(--ether-gold)" style="background:var(--ether-gold)"></div>

        <!-- Black (shape mode) -->
        <div class="color-swatch" data-color="var(--ether-black)" style="background:var(--ether-black)"></div>
      </div>

      <div class="pill">
        <span>Size</span>
        <input id="size" type="range" min="1" max="40" value="6" />
        <span id="sizeLabel">6</span>
      </div>

      <div class="pill">
        <span>Light+</span>
        <input id="light" type="range" min="0.20" max="1.00" step="0.05" value="0.85" />
        <span id="lightLabel">0.85</span>
      </div>

      <div class="pill">
        <span>Shape</span>
        <button class="shape-btn active" data-shape="square" type="button">â–¡</button>
        <button class="shape-btn" data-shape="circle" type="button">â—‹</button>
        <button class="shape-btn" data-shape="star" type="button">â˜…</button>
        <button class="shape-btn" data-shape="pentagon" type="button">â¬Ÿ</button>
      </div>

      <button id="clearBtn" class="clear-x" type="button" aria-label="Clear canvas">
        Ã—
      </button>

      <button id="saveBtn" class="save-light" type="button">Save Light</button>
    </div>

    <div class="stage">
      <canvas id="c"></canvas>
    </div>

    <div class="footer">
      Tip: if anything feels unstable, revert to the last working commit.
    </div>
  </div>

  <!-- ðŸŸ¢ LOGIC ZONE -->
  <script>
    // Explicit override (S1A): set false to export without background
    const EXPORT_BACKGROUND = true;

    const canvas = document.getElementById("c");
    const ctx = canvas.getContext("2d");

    const sizeInput  = document.getElementById("size");
    const sizeLabel  = document.getElementById("sizeLabel");

    const lightInput = document.getElementById("light");
    const lightLabel = document.getElementById("lightLabel");

    const clearBtn   = document.getElementById("clearBtn");
    const saveBtn    = document.getElementById("saveBtn");

    let brushSize = Number(sizeInput.value);
    sizeLabel.textContent = brushSize;

    let brushAlpha = Number(lightInput.value);
    lightLabel.textContent = brushAlpha.toFixed(2);

    const rootStyle = getComputedStyle(document.documentElement);
    const blackHex = rootStyle.getPropertyValue('--ether-black').trim();

    let brushColor = rootStyle.getPropertyValue('--ether-ink').trim();

    // Shape state (black-only)
    let shapeMode = "square";

    // Swatches: set brushColor + active ring
    const swatches = Array.from(document.querySelectorAll('.color-swatch'));
    swatches.forEach(swatch => {
      swatch.addEventListener('click', () => {
        swatches.forEach(s => s.classList.remove('active'));
        swatch.classList.add('active');

        const varName = swatch.dataset.color.replace('var(','').replace(')','');
        brushColor = getComputedStyle(document.documentElement)
          .getPropertyValue(varName)
          .trim();
      });
    });

    // Shape buttons
    const shapeBtns = Array.from(document.querySelectorAll('.shape-btn'));
    shapeBtns.forEach(btn => {
      btn.addEventListener('click', () => {
        shapeBtns.forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        shapeMode = btn.dataset.shape;
      });
    });

    // UI controls
    sizeInput.addEventListener("input", () => {
      brushSize = Number(sizeInput.value);
      sizeLabel.textContent = brushSize;
    });

    lightInput.addEventListener("input", () => {
      brushAlpha = Number(lightInput.value);
      lightLabel.textContent = brushAlpha.toFixed(2);
    });

    // Canvas sizing (no white fill; background is the stage gradient)
    function resizeCanvasToDisplaySize(){
      const rect = canvas.getBoundingClientRect();
      const dpr = Math.max(1, window.devicePixelRatio || 1);

      const w = Math.floor(rect.width * dpr);
      const h = Math.floor(rect.height * dpr);

      if (canvas.width !== w || canvas.height !== h){
        canvas.width = w;
        canvas.height = h;
      }
    }

    window.addEventListener("resize", resizeCanvasToDisplaySize);
    setTimeout(resizeCanvasToDisplaySize, 0);

    // Clear: return to empty (transparent) so dark bg shows through
    clearBtn.addEventListener("click", () => {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
    });

    // Save: ink/grey gradient baked behind (unless override off)
    saveBtn.addEventListener("click", () => {
      const d = new Date();
      const yyyy = d.getFullYear();
      const mm = String(d.getMonth() + 1).padStart(2, "0");
      const dd = String(d.getDate()).padStart(2, "0");
      const filename = `lightpaint_a_${yyyy}_${mm}_${dd}.png`;

      const out = document.createElement("canvas");
      out.width = canvas.width;
      out.height = canvas.height;

      const octx = out.getContext("2d");

      if (EXPORT_BACKGROUND){
        const g = octx.createLinearGradient(0, 0, 0, out.height);
        g.addColorStop(0, "#070a16");
        g.addColorStop(1, "#2b2f3a");
        octx.fillStyle = g;
        octx.fillRect(0, 0, out.width, out.height);
      }

      octx.drawImage(canvas, 0, 0);

      const link = document.createElement("a");
      link.download = filename;
      link.href = out.toDataURL("image/png");
      link.click();
    });

    // --- Shape preview (black mode): click-drag resize (S4A) ---
    let shaping = false;
    let shapeStart = { x: 0, y: 0 };
    let shapeSnapshot = null;
    let pendingFrame = false;
    let lastPreviewPoint = null;

    function polygonPath(cx, cy, radius, sides, rotation = -Math.PI / 2){
      ctx.beginPath();
      for (let i = 0; i < sides; i++){
        const a = rotation + (i * 2 * Math.PI / sides);
        const x = cx + radius * Math.cos(a);
        const y = cy + radius * Math.sin(a);
        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      }
      ctx.closePath();
    }

    function starPath(cx, cy, outerR, innerR, points = 5, rotation = -Math.PI / 2){
      ctx.beginPath();
      const step = Math.PI / points;
      for (let i = 0; i < points * 2; i++){
        const r = (i % 2 === 0) ? outerR : innerR;
        const a = rotation + i * step;
        const x = cx + r * Math.cos(a);
        const y = cy + r * Math.sin(a);
        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      }
      ctx.closePath();
    }

    function drawBlackShape(cx, cy, radius, preview = false){
      ctx.save();
      ctx.globalAlpha = Math.min(1, Math.max(0.05, brushAlpha));
      ctx.fillStyle = blackHex;

      // Slightly soften edges when previewing (optional, still simple)
      if (preview){
        ctx.shadowBlur = 0;
      }

      if (shapeMode === "square"){
        const s = radius * 1.6;
        ctx.beginPath();
        ctx.rect(cx - s/2, cy - s/2, s, s);
        ctx.fill();
      } else if (shapeMode === "circle"){
        ctx.beginPath();
        ctx.arc(cx, cy, radius, 0, Math.PI * 2);
        ctx.fill();
      } else if (shapeMode === "pentagon"){
        polygonPath(cx, cy, radius, 5);
        ctx.fill();
      } else if (shapeMode === "star"){
        starPath(cx, cy, radius, radius * 0.45, 5);
        ctx.fill();
      }

      ctx.restore();
    }

    // --- Painting ---
    let drawing = false;
    let last = { x: 0, y: 0 };

    function getPoint(e){
      const rect = canvas.getBoundingClientRect();
      const dpr = Math.max(1, window.devicePixelRatio || 1);

      const clientX = e.touches ? e.touches[0].clientX : e.clientX;
      const clientY = e.touches ? e.touches[0].clientY : e.clientY;

      return {
        x: (clientX - rect.left) * dpr,
        y: (clientY - rect.top) * dpr
      };
    }

    function paintSegment(from, to){
      ctx.save();

      // Halo/glow (S3A): match stroke color
      ctx.globalAlpha = Math.min(1, Math.max(0.05, brushAlpha));
      ctx.shadowBlur = Math.max(6, brushSize * 2.2);
      ctx.shadowColor = brushColor;

      ctx.lineCap = "round";
      ctx.lineJoin = "round";
      ctx.strokeStyle = brushColor;
      ctx.lineWidth = brushSize;

      ctx.beginPath();
      ctx.moveTo(from.x, from.y);
      ctx.lineTo(to.x, to.y);
      ctx.stroke();

      ctx.restore();
    }

    function start(e){
      resizeCanvasToDisplaySize();
      const p = getPoint(e);

      // Black mode => shape drag-resize
      if (brushColor === blackHex){
        shaping = true;
        shapeStart = p;
        lastPreviewPoint = p;

        // Snapshot once for clean preview restore
        try{
          shapeSnapshot = ctx.getImageData(0, 0, canvas.width, canvas.height);
        }catch(err){
          shapeSnapshot = null; // if browser blocks for any reason, we still commit on end
        }

        e.preventDefault();
        return;
      }

      // Color paint mode
      drawing = true;
      last = p;
      e.preventDefault();
    }

    function move(e){
      const p = getPoint(e);

      // Shape preview while dragging
      if (shaping){
        lastPreviewPoint = p;

        if (!pendingFrame){
          pendingFrame = true;
          requestAnimationFrame(() => {
            pendingFrame = false;

            if (shapeSnapshot){
              ctx.putImageData(shapeSnapshot, 0, 0);
            } else {
              // If we couldn't snapshot, do nothing preview-wise (still stable)
              return;
            }

            const dx = lastPreviewPoint.x - shapeStart.x;
            const dy = lastPreviewPoint.y - shapeStart.y;
            const r = Math.max(4, Math.sqrt(dx*dx + dy*dy)); // radius from drag distance

            drawBlackShape(shapeStart.x, shapeStart.y, r, true);
          });
        }

        e.preventDefault();
        return;
      }

      // Paint mode
      if (!drawing) return;
      paintSegment(last, p);
      last = p;
      e.preventDefault();
    }

    function end(){
      // Commit shape on release
      if (shaping){
        shaping = false;

        if (shapeSnapshot && lastPreviewPoint){
          // Restore clean base then commit final shape (no preview artifacts)
          ctx.putImageData(shapeSnapshot, 0, 0);

          const dx = lastPreviewPoint.x - shapeStart.x;
          const dy = lastPreviewPoint.y - shapeStart.y;
          const r = Math.max(4, Math.sqrt(dx*dx + dy*dy));

          drawBlackShape(shapeStart.x, shapeStart.y, r, false);
        }

        shapeSnapshot = null;
        lastPreviewPoint = null;
        return;
      }

      drawing = false;
    }

    // Mouse
    canvas.addEventListener("mousedown", start);
    window.addEventListener("mousemove", move);
    window.addEventListener("mouseup", end);

    // Touch
    canvas.addEventListener("touchstart", start, { passive:false });
    canvas.addEventListener("touchmove", move, { passive:false });
    canvas.addEventListener("touchend", end);
  </script>
</body>
</html>
